/* background.js - Chrome Built-in AI Background ServiceÔºàÁßªÈô§ SW ‰∏≠ÁöÑ self.aiÔºåÁªü‰∏ÄËΩ¨ÂèëÂà∞ Offscreen/LanguageModelÔºâ */

// ========================================
// Extension icon click event - Open Side Panel
// ========================================
chrome.action.onClicked.addListener(async (tab) => {
  try {
    // Open Side Panel
    await chrome.sidePanel.open({ windowId: tab.windowId });
    console.log('‚úÖ Side Panel opened');
  } catch (error) {
    console.error('‚ùå Open Side Panel Â§±Ë¥•:', error);
    // If open fails, try setting and opening
    try {
      await chrome.sidePanel.setOptions({
        tabId: tab.id,
        path: 'sidepanel.html',
        enabled: true
      });
      await chrome.sidePanel.open({ windowId: tab.windowId });
    } catch (retryError) {
      console.error('‚ùå ÈáçËØïOpen Side Panel Â§±Ë¥•:', retryError);
    }
  }
});

let chromeAIManager = null;
let aiCapabilities = null;           
let modelStatus = 'checking';        
let database = null;

const ICON = 'icon128.png';          

// OffscreenÔºöCreate only once when needed; forward all AI calls
async function ensureOffscreen() {
  const has = await chrome.offscreen.hasDocument?.();
  if (!has) {
    await chrome.offscreen.createDocument({
      url: 'offscreen.html',
      reasons: ['IFRAME_SCRIPTING'],        
      justification: 'Run on-device LanguageModel in a page context'
    });
  }
}

// Improved: Proactive warmup (with retry)
async function prewarmLM() {
  console.log('[BG] üî• Starting model prewarm...');
  
  for (let attempt = 1; attempt <= 3; attempt++) {
    try {
      await ensureOffscreen();
      console.log(`[BG] üî• Prewarm attempt ${attempt}/3...`);
      
      const result = await chrome.runtime.sendMessage({ action: 'OFFSCREEN_PREWARM' });
      
      if (result?.ok) {
        console.log('[BG] ‚úÖ Model prewarmed successfully');
        modelStatus = 'ready';
        return;
      } else {
        console.warn(`[BG] ‚ö†Ô∏è Prewarm attempt ${attempt} returned not ok:`, result?.error);
      }
    } catch (e) {
      console.warn(`[BG] ‚ö†Ô∏è Prewarm attempt ${attempt} failed:`, e?.message || e);
      
      // If first attempt fails, wait longer (model may be downloading)
      if (attempt < 3) {
        const waitTime = attempt === 1 ? 5000 : 3000;
        console.log(`[BG] ‚è≥ Waiting ${waitTime}ms before retry...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
  }
  
  console.warn('[BG] ‚ö†Ô∏è Model prewarm failed after 3 attempts. Will retry on first use.');
}


// 
function callOffscreen(action, payload = {}, timeoutMs = 120000) {
  return new Promise(async (resolve) => {
    await ensureOffscreen();
    let done = false;
    const timer = setTimeout(() => {
      if (!done) {
        console.error(`‚è±Ô∏è Offscreen timeout (${timeoutMs}ms):`, action);
        resolve({ ok: false, error: 'OFFSCREEN_TIMEOUT' });
      }
    }, timeoutMs);

    chrome.runtime.sendMessage({ action, ...payload }, (resp) => {
      done = true;
      clearTimeout(timer);

      // Message channel error
      const le = chrome.runtime.lastError;
      if (le) {
        resolve({ ok: false, error: le.message || 'Message channel error' });
        return;
      }

      // Normal return
      resolve(resp);
    });
  });
}


// 1. Initialization Chrome AI ÊúçÂä°
async function initializeServices() {
  try {
    console.log('üöÄ Initialization SmartInsight Chrome AI ÊúçÂä°...');
    // Improved: No longer touch self.ai in SW, use offscreen SMOKE test
    await checkChromeAIAvailability();      
    await initializeChromeAI();             
    await initializeDatabase();             

    console.log('‚úÖ SmartInsight Chrome AI ÊúçÂä°InitializationÂÆåÊàê');
    try {
      chrome.notifications.create({
        type: 'basic',
        iconUrl: ICON,
        title: 'SmartInsight Ready',
        message: 'üîí Privacy First | ‚ö° Local AI | üí∞ Completely Free'
      });
    } catch (_) {}
  } catch (error) {
    console.error('‚ùå Chrome AI ÊúçÂä°InitializationÂ§±Ë¥•:', error);
    modelStatus = 'error';
    try {
      chrome.notifications.create({
        type: 'basic',
        title: 'Chrome AI Setup Required',
        message: 'Please enable Chrome AI features for full analysis'
      });
    } catch (_) {}
  }
}

// Improved: Check Chrome AI availability (replaced with Offscreen self-check)
async function checkChromeAIAvailability() {
  console.log('üîç Checking Chrome AI availability (via Offscreen)...');
  aiCapabilities = { prompt: null, summarizer: null, translator: null, writer: null };

  try {
    const smoke = await callOffscreen('OFFSCREEN_SMOKE');
    if (smoke?.ok) {
      modelStatus = 'ready';
      aiCapabilities.prompt = 'readily';   
      // Don't check details, only check LanguageModel availability()
    } else {
      modelStatus = 'unavailable';
    }
  } catch (e) {
    modelStatus = 'error';
    console.warn('Offscreen smoke failed:', e?.message || e);
  }
}

// Initialization Chrome AI Manager
async function initializeChromeAI() {
  try {
    console.log('ü§ñ Initialization Chrome AI Manager...');
    chromeAIManager = {
      // ÂàÜÊûê LinkedIn Profile 
      analyzeProfile: async (profileData) => analyzeProfileWithChromeAI(profileData),
      // Analyze company info
      analyzeCompany: async (companyData) => analyzeCompanyWithChromeAI(companyData),
      // Summarize content
      summarizeContent: async (content)   => summarizeWithChromeAI(content),
      // Get performance stats
      getStats: async () => ({
        modelStatus,
        capabilities: aiCapabilities,
        cost: 0,
        privacy: '100% Local processing',
        latency: '<1Áßí',
        requests: 0
      })
    };
    console.log('‚úÖ Chrome AI Manager InitializationÂÆåÊàê');
  } catch (error) {
    console.error('‚ùå Chrome AI Manager InitializationÂ§±Ë¥•:', error);
    throw error;
  }
}

// Chrome AI analysis functions (internally forward to Offscreen using LanguageModel)
async function analyzeProfileWithChromeAI(profileData) {
  const startTime = performance.now();
  try {
    console.log('üîç ‰ΩøÁî® Chrome AI ÂàÜÊûêProfile...');
    const prompt = buildProfileAnalysisPrompt(profileData);
    const result = await callChromeAIPrompt(prompt);              
    const structuredResult = parseProfileAnalysis(result);
    const latency = performance.now() - startTime;
    console.log(`‚úÖ ProfileÂàÜÊûêÂÆåÊàêÔºåËÄóÊó∂: ${Math.round(latency)}ms`);
    return {
      ...structuredResult,
      metadata: {
        ...structuredResult.metadata,
        processing_time: Math.round(latency),
        ai_model: 'Gemini Nano (Chrome Built-in)',
        privacy: '100% Local processingÔºåÊï∞ÊçÆ‰∏çÁ¶ªÂºÄËÆæÂ§á'
      }
    };
  } catch (error) {
    console.error('Chrome AI ProfileAnalysis failed:', error);
    throw new Error(`Analysis failed: ${error.message}`);
  }
}

async function analyzeCompanyWithChromeAI(companyData) {
  const startTime = performance.now();
  try {
    console.log('üè¢ ‰ΩøÁî® Chrome AI Analyze company infoÔºàÁªè Offscreen/LanguageModelÔºâ...');
    const prompt = buildCompanyAnalysisPrompt(companyData);
    const result = await callChromeAIPrompt(prompt);              // „ÄêÊ†áÊ≥®„ÄëÊîπÔºöËΩ¨Âèë
    const structuredResult = parseCompanyAnalysis(result);
    const latency = performance.now() - startTime;
    console.log(`‚úÖ Company analysis complete, time: ${Math.round(latency)}ms`);
    return {
      ...structuredResult,
      metadata: {
        ...structuredResult.metadata,
        processing_time: Math.round(latency),
        ai_model: 'Gemini Nano (Chrome Built-in)',
        privacy: '100% Local processing'
      }
    };
  } catch (error) {
    console.error('Chrome AI ÂÖ¨Âè∏Analysis failed:', error);
    throw new Error(`Analysis failed: ${error.message}`);
  }
}

async function summarizeWithChromeAI(content) {
  try {
    console.log('üìÑ ‰ΩøÁî® Chrome AI Summarize content...');
    // Improved: Try OFFSCREEN_SUMMARY first; fallback to OFFSCREEN_PROMPT if not implemented
    const resp = await callOffscreen('OFFSCREEN_SUMMARY', { text: content });
    if (resp?.ok) return resp.data;

    // Fallback: Construct concise English instruction for LM to output key points
    const prompt = `Summarize the following content into concise bullet points:\n\n${content}`;
    return await callChromeAIPrompt(prompt);
  } catch (error) {
    console.error('Chrome AI content summarization failed:', error);
    throw new Error(`Summarization failed: ${error.message}`);
  }
}


// Improved: Chrome AI core call function (changed from SW to forward to Offscreen/LanguageModel)

async function callChromeAIPrompt(prompt) {
  if (modelStatus !== 'ready') {
    throw new Error('Chrome AI not ready (Offscreen smoke failed).');
  }
  const resp = await callOffscreen('OFFSCREEN_PROMPT', { text: prompt });
  if (resp?.ok) return resp.data;
  throw new Error(resp?.error || 'OFFSCREEN_PROMPT failed');
}


// BuildingÂàÜÊûêNotificationËØç

function buildProfileAnalysisPrompt(profileData) {
  return `As a professional career consultant, please analyze the following LinkedIn profile and provide career advice:

Personal Information:
- Name:${profileData.basic_info?.name || 'Not provided'}
- Position:${profileData.basic_info?.headline || 'Not provided'}
- Current Company:${profileData.current_position?.company || 'Not provided'}

Work Experience:
${profileData.experiences?.map(exp => `- ${exp.title} at ${exp.company} (${exp.duration})`).join('\n') || 'Not provided'}

Education:
${profileData.education?.map(edu => `- ${edu.degree} in ${edu.field} from ${edu.school}`).join('\n') || 'Not provided'}

Please provide the following analysis:

**Key Highlights** (3 key points)
**Icebreaker** (1-2 natural conversation opener)
**Deep Questions** (3 questions for deep discussion)
**Quick Notes** (3 key memory points)
**Follow-up Email Template** (professional follow-up email)

Please ensure advice is practical, natural and professional.`;
}

function buildCompanyAnalysisPrompt(companyData) {
  return `As a career analyst, please analyze the following company information and provide interview preparation advice:

Company Name:${companyData.companyName || 'Not provided'}
ÁõÆÊ†áPosition:${companyData.targetPosition || 'Not provided'}
Company Website:${companyData.companyUrl || 'Not provided'}
Additional Info:${companyData.additionalInfo || 'Not provided'}

Please provide the following analysis:

**Company Positioning** (1 sentence summary)
**Development Timeline** (key development stages)
**Core Team** (leadership characteristics)
**Competitive Advantage** (market position analysis)
**Interview Tips** (specific preparation points)
**Suggested Questions** (3 questions to ask the interviewer)

Please ensure analysis is objective, practical and targeted.`;
}

// InitializationLocal database
async function initializeDatabase() {
  try {
    console.log('üíæ InitializationLocal database...');
    database = {
      saveProfile: async (profile) => {
        const key = `profile_${Date.now()}`;
        await chrome.storage.local.set({ [key]: profile });
        console.log('‚úÖ ProfileÂ∑≤‰øùÂ≠òÂà∞Êú¨Âú∞');
      },
      getProfile: async (url) => {
        const result = await chrome.storage.local.get();
        const profiles = Object.values(result).filter(item => item.profile_url === url);
        return profiles.length > 0 ? profiles[0] : null;
      },
      saveCompany: async (company) => {
        const key = `company_${Date.now()}`;
        await chrome.storage.local.set({ [key]: company });
        console.log('‚úÖ Company info saved locally');
      },
      getCompany: async (name) => {
        const result = await chrome.storage.local.get();
        const companies = Object.values(result).filter(item => item.company_name === name);
        return companies.length > 0 ? companies[0] : null;
      },
      getCostSummary: async () => ({
        totalCost: 0, requestCount: 0, privacy: '100% Local processing'
      })
    };
    console.log('‚úÖ Local databaseInitializationÂÆåÊàê');
  } catch (error) {
    console.error('‚ùå Êï∞ÊçÆÂ∫ìInitializationÂ§±Ë¥•:', error);
  }
}

// Result parsing and helper functions
function parseProfileAnalysis(rawResult) {
  const sections = parseAIResponse(rawResult);
  return {
    flashcard: {
      key_points: extractKeyPoints(sections),
      golden_quote: extractGoldenQuote(sections),
      reading_time: 30
    },
    icebreaker: {
      icebreaker: extractIcebreaker(sections),
      tone: 'professional',
      based_on_sources: ['LinkedIn Profile', 'Chrome AI Analysis']
    },
    questions: extractQuestions(sections),
    email_draft: extractEmailDraft(sections),
    metadata: {
      cost_usd: 0,
      processing_time: 0,
      privacy: '100% Local processingÔºåÊï∞ÊçÆ‰∏çÁ¶ªÂºÄËÆæÂ§á',
      ai_model: 'Gemini Nano (Chrome Built-in)'
    }
  };
}
function parseCompanyAnalysis(rawResult) {
  const sections = parseAIResponse(rawResult);
  return {
    positioning: extractPositioning(sections),
    timeline: extractTimeline(sections),
    keyPeople: extractKeyPeople(sections),
    competition: extractCompetition(sections),
    interviewTips: extractInterviewTips(sections),
    suggestedQuestions: extractSuggestedQuestions(sections),
    metadata: {
      cost_usd: 0,
      processing_time: 0,
      privacy: '100% Local processing',
      ai_model: 'Gemini Nano (Chrome Built-in)'
    }
  };
}
function parseAIResponse(response) {
  const sections = {};
  const lines = response.split('\n');
  let currentSection = null;
  let currentContent = [];
  for (const line of lines) {
    if (line.includes('**') || line.includes('#')) {
      if (currentSection) sections[currentSection] = currentContent.join('\n').trim();
      currentSection = line.replace(/[*#]/g, '').trim().toLowerCase();
      currentContent = [];
    } else if (line.trim()) {
      currentContent.push(line.trim());
    }
  }
  if (currentSection) sections[currentSection] = currentContent.join('\n').trim();
  return sections;
}
// ÊèêÂèñÂÖ∑‰ΩìÂÜÖÂÆπÁöÑËæÖÂä©ÂáΩÊï∞
function extractKeyPoints(sections) {
  const keyPointsText = sections['Key Highlights'] || sections['key highlights'] || '';
  return keyPointsText.split('\n').filter(line => line.trim()).slice(0, 3);
}
function extractGoldenQuote(sections) {
  const icebreakerText = sections['Icebreaker'] || sections['icebreaker'] || '';
  return icebreakerText.split('\n')[0] || 'ÂáÜÂ§áÂÖÖÂàÜÁöÑÂØπËØùÊòØÊàêÂäüÁΩëÁªúÂª∫ËÆæÁöÑto start';
}
function extractIcebreaker(sections) {
  return sections['Icebreaker'] || sections['icebreaker'] || 'ÂæàÈ´òÂÖ¥ËÆ§ËØÜÊÇ®ÔºåÊàëÂØπÊÇ®Âú®ËØ•È¢ÜÂüüÁöÑÁªèÈ™åÂæàÊÑüÂÖ¥Ë∂£„ÄÇ';
}
function extractQuestions(sections) {
  const questionsText = sections['Deep Questions'] || sections['deep questions'] || '';
  const questionLines = questionsText.split('\n').filter(line => line.trim());
  return questionLines.slice(0, 3).map((question, index) => ({
    text: question.replace(/^[-*]\s*/, ''),
    priority: index === 0 ? 'P0' : index === 1 ? 'P1' : 'P2',
    category: '‰∏ì‰∏ö‰∫§ÊµÅ',
    source: 'Chrome AI Analysis'
  }));
}
function extractEmailDraft(sections) {
  const emailText = sections['Follow-up Email Template'] || sections['follow-up email'] || '';
  return {
    subject: 'ÂæàÈ´òÂÖ¥ËÆ§ËØÜÊÇ®',
    body: emailText || 'ÊÑüË∞¢‰ªäÂ§©ÁöÑÊÑâÂø´‰∫§ÊµÅÔºåÊúüÂæÖÊú™Êù•ÊúâÊú∫‰ºöËøõ‰∏ÄÊ≠•Âêà‰Ωú„ÄÇ',
    tone: 'professional',
    call_to_action: 'follow_up'
  };
}
function extractPositioning(sections) {
  return sections['Company Positioning'] || sections['company positioning'] || 'ÂàõÊñ∞ÂûãË°å‰∏öÈ¢ÜÂÖà‰ºÅ‰∏ö';
}
function extractTimeline(sections) {
  return sections['Development Timeline'] || sections['timeline'] || 'Á®≥Ê≠•ÂèëÂ±ïÔºåÊåÅÁª≠ÂàõÊñ∞';
}
function extractKeyPeople(sections) {
  return sections['Core Team'] || sections['key people'] || 'ÁªèÈ™å‰∏∞ÂØåÁöÑÁÆ°ÁêÜÂõ¢Èòü';
}
function extractCompetition(sections) {
  return sections['Competitive Advantage'] || sections['competitive advantage'] || 'Âú®Ë°å‰∏ö‰∏≠ÂÖ∑ÊúâÁã¨Áâπ‰ºòÂäø';
}
function extractInterviewTips(sections) {
  return sections['Interview Tips'] || sections['interview tips'] || 'Â±ïÁ§∫Áõ∏ÂÖ≥ÊäÄËÉΩÂíåÁªèÈ™åÔºåË°®ËææÂØπÂÖ¨Âè∏ÁöÑÂÖ¥Ë∂£';
}
function extractSuggestedQuestions(sections) {
  const questionsText = sections['Suggested Questions'] || sections['suggested questions'] || '';
  return questionsText.split('\n').filter(line => line.trim()).slice(0, 3);
}


// ÁÆÄÂåñÁöÑÂ∑•‰ΩúÊµÅÊâßË°åÔºàÂéüÊ†∑‰øùÁïôÔºâ

async function executeSimplifiedWorkflow(workflowName, data, context) {
  try {
    if (workflowName === 'chat_prep') {
      return await chromeAIManager.analyzeProfile(data);
    } else if (workflowName === 'company_analysis') {
      return await chromeAIManager.analyzeCompany(data);
    }
    throw new Error(`Unknown workflow: ${workflowName}`);
  } catch (error) {
    console.error('Chrome AI workflow execution failed:', error);
    throw error;
  }
}


// Chrome AI Áõ¥Êé•Ë∞ÉÁî®ÔºàÂÖºÂÆπÊóßÊé•Âè£ÔºâÊîπÔºöÊää‚ÄúÂ§ñÈÉ® LLM Ë∞ÉÁî®‚ÄùÊõøÊç¢‰∏∫Êú¨Âú∞ LMÔºàËΩ¨ÂèëÔºâ

async function callLLMDirect(params) {
  try {
    console.log('üîÑ ‰ΩøÁî® Chrome Êú¨Âú∞ AI Êõø‰ª£Â§ñÈÉ® API...');
    const result = await callChromeAIPrompt(params.prompt);
    return {
      content: result,
      usage: { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 },
      model: 'Gemini Nano (Chrome Built-in)',
      cost: 0,
      privacy: '100% Local processing'
    };
  } catch (error) {
    console.error('Chrome AI call failed:', error);
    throw new Error(`Chrome AI Ë∞ÉÁî®Â§±Ë¥•: ${error.message}`);
  }
}


// 2. Â¢ûÂº∫ÁöÑÊ∂àÊÅØÂ§ÑÁêÜÂô®ÔºàÊîπÔºöÊää AI Âä®‰ΩúË∑ØÁî±Âà∞ offscreenÔºâ
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log('DEBUG [BG]: Received action:', request.action);
  (async () => {
    // Â§ÑÁêÜ‰∏çÂêåÁ±ªÂûãÁöÑËØ∑Ê±Ç
    switch (request.action) {
      // Listen for model download progress
      case 'MODEL_DOWNLOAD_PROGRESS': {
        const progress = request.progress || 0;
        console.log(`üì• Model downloading: ${progress}%`);
        
        // Á¨¨‰∏ÄÊ¨°‰∏ãËΩΩÊó∂ÊòæÁ§∫ÈÄöÁü•
        if (progress === 0 || progress === 1) {
          try {
            chrome.notifications.create('model-download', {
              type: 'basic',
              iconUrl: ICON,
              title: 'Chrome AI Ê®°Âûã‰∏ãËΩΩ‰∏≠',
              message: 'First use requires model download, please wait...',
              priority: 2
            });
          } catch (_) {}
        }
        
        // ‰∏ãËΩΩÂÆåÊàêÊó∂Êõ¥Êñ∞ÈÄöÁü•
        if (progress >= 100) {
          try {
            chrome.notifications.create('model-ready', {
              type: 'basic',
              iconUrl: ICON,
              title: 'Chrome AI Model Ready',
              message: '‚úÖ Model download complete, ready to use!',
              priority: 2
            });
          } catch (_) {}
        }
        
        sendResponse({ status: 'SUCCESS' });
        break;
      }
      
      // ÁõëÂê¨Ê®°ÂûãÂ∞±Áª™‰∫ã‰ª∂
      case 'MODEL_READY': {
        console.log('‚úÖ Chrome AI Ê®°ÂûãÂ∑≤Â∞±Áª™');
        modelStatus = 'ready';
        sendResponse({ status: 'SUCCESS' });
        break;
      }
      
      // Check model status
      case 'CHECK_MODEL_STATUS': {
        console.log('[BG] Received model status check request, current status:', modelStatus);
        sendResponse({ status: modelStatus });
        break;
      }
      
      case 'RUN_SUMMARY': {
        const r = await callOffscreen('OFFSCREEN_SUMMARY', { text: request.text, url: request.url });
        if (r?.ok) sendResponse({ status: 'SUCCESS', output: r.data });
        else sendResponse({ status: 'ERROR', message: r?.error || 'OFFSCREEN_SUMMARY failed' });
        break;
      }

      case 'ANALYZE_PROFILE':
        await handleProfileAnalysis(request, sendResponse);
        break;

      case 'ANALYZE_COMPANY':
        await handleCompanyAnalysis(request, sendResponse);
        break;

      case 'ANALYZE_WEBSITE':
        await handleWebsiteAnalysis(request, sendResponse);
        break;

      case 'GET_STATS':
        await handleGetStats(request, sendResponse);
        break;

      case 'GET_LINKEDIN_PROFILE_DATA':
        await handleGetLinkedInProfileData(request, sendResponse);
        return true; // ÊîπÔºöÂºÇÊ≠•ÂìçÂ∫î 

      // Êñ∞Â¢ûÔºöscenariosÂª∫ËÆÆÁîüÊàê
      case 'GENERATE_SCENARIO_ADVICE':
        await handleScenarioAdvice(request, sendResponse);
        break;

      // Êñ∞Â¢ûÔºöËÅäÂ§©Ê∂àÊÅØÂ§ÑÁêÜ
      case 'CHAT_MESSAGE':
        await handleChatMessage(request, sendResponse);
        break;

      // Êñ∞Â¢ûÔºöOpen Side Panel
      case 'OPEN_SIDE_PANEL':
        await handleOpenSidePanel(request, sender, sendResponse);
        break;

      // Êñ∞Â¢ûÔºöËá™Âä®Import LinkedIn
      case 'AUTO_IMPORT_LINKEDIN':
        await handleAutoImportLinkedIn(request, sender, sendResponse);
        break;
      
      // ÂèåÂêç popup
      case 'CHAT_PREP':
      case 'ANALYZE_PROFILE': {
        const d = request?.data || {};
        const hasProfile = !!(d.basic_info || d.experiences || d.education);

        // 1) ‰ºòÂÖàÔºöÁé∞ÊàêÁªìÊûÑÂåñÂàÜÊûê
        let text = '';
        if (hasProfile) {
          console.log('[BG][PATH] profile:structured -> chromeAIManager.analyzeProfile');
          try {
            const r = await chromeAIManager.analyzeProfile(d);

            // Âà§Á©∫ÔºöÊ≤°ÂÜÖÂÆπÊó∂Ëµ∞ÂÖúÂ∫ï
            const hasAny =
              (Array.isArray(r?.flashcard?.key_points) && r.flashcard.key_points.length) ||
              (r?.icebreaker?.icebreaker) ||
              (Array.isArray(r?.questions) && r.questions.length) ||
              (r?.email_draft?.body);

            if (hasAny) {
              const keyPoints = Array.isArray(r.flashcard?.key_points) ? r.flashcard.key_points : [];
              const qs = Array.isArray(r.questions) ? r.questions.map(q => `- ${q.text}`).join('\n') : '';
              const ice = r.icebreaker?.icebreaker || '';
              const email = r.email_draft?.body || '';
              text =
                (keyPoints.length ? `**Key Highlights**\n${keyPoints.map(x=>`- ${x}`).join('\n')}\n\n` : '') +
                (ice ? `**Icebreaker**\n${ice}\n\n` : '') +
                (qs ? `**Deep Questions**\n${qs}\n\n` : '') +
                (email ? `**Follow-up Email Template**\n${email}\n` : '');
            }
          } catch (e) {
            console.warn('[BG] analyzeProfile failed, will fallback:', e?.message || e);
          }
        }

        // 2) ÂÖúÂ∫ïÔºöËá™Áî±ÂõûÁ≠îÔºàÊûÅÁÆÄ‰∏ä‰∏ãÊñá ‚Üí ‰∏ÄÂè•ËØù promptÔºâ
        if (!text) {
          console.log('[BG][PATH] profile:fallback-prompt -> callChromeAIPrompt');
          const ctx = [
            d.basic_info?.name && `Name: ${d.basic_info.name}`,
            d.basic_info?.headline && `Title: ${d.basic_info.headline}`,
            d.current_position?.company && `Current Company: ${d.current_position.company}`,
            Array.isArray(d.experiences) && d.experiences.length &&
              `Experience:\n${d.experiences.slice(0,3).map(e=>`- ${e.title} @ ${e.company} (${e.duration||''})`).join('\n')}`,
            Array.isArray(d.education) && d.education.length &&
              `Education:\n${d.education.slice(0,2).map(e=>`- ${e.degree} ${e.field||''} ‚Äî ${e.school}`).join('\n')}`,
            d.notes && `Notes: ${d.notes}`
          ].filter(Boolean).join('\n');

          const prompt =
            `You are a career networking assistant. Based on the context below, provide direct results (no explanations):
            - 3 natural icebreaker conversation starters
            - 3 in-depth questions
            - 1 follow-up suggestion
            Requirements: English, bullet points, specific and natural.

      ${ctx || '(No context provided)'}`;

          text = await callChromeAIPrompt(prompt);
        }

        sendResponse({ status: 'SUCCESS', output: text || 'No analysis.' });
        break;
      }


      // popup ‰∏çÂª∫Êñ∞ÂáΩÊï∞
      case 'COMPANY_ANALYSIS':
      case 'ANALYZE_COMPANY': {
        const d = request?.data || {};
        const hasInput = !!(d.companyName || d.companyUrl || d.additionalInfo);

        // 1) ‰ºòÂÖàÔºöÁé∞ÊàêÁªìÊûÑÂåñÂàÜÊûê
        let text = '';
        if (hasInput) {
          console.log('[BG][PATH] company:structured -> chromeAIManager.analyzeCompany');
          try {
            const r = await chromeAIManager.analyzeCompany(d);

            // Âà§Á©∫ÔºöÊ≤°ÂÜÖÂÆπÊó∂Ëµ∞ÂÖúÂ∫ï
            const hasAny =
              r?.positioning ||
              (Array.isArray(r?.timeline) && r.timeline.length) ||
              (Array.isArray(r?.keyPeople) && r.keyPeople.length) ||
              (Array.isArray(r?.competition) && r.competition.length) ||
              (Array.isArray(r?.interviewTips) && r.interviewTips.length) ||
              (Array.isArray(r?.suggestedQuestions) && r.suggestedQuestions.length);

            if (hasAny) {
              const sec = (t, b) => b ? `**${t}**\n${b}\n\n` : '';
              const list = a => Array.isArray(a)&&a.length ? a.map(x=>`- ${x}`).join('\n') : '';

              text =
                sec('Company Positioning', r.positioning || '') +
                sec('ÂÖ≥ÈîÆÊó∂Èó¥Á∫ø', list(r.timeline)) +
                sec('Core Team', list(r.keyPeople)) +
                sec('Competitive Advantage', list(r.competition)) +
                sec('Interview Tips', list(r.interviewTips)) +
                sec('ÂèØÊèêÈóÆÈ¢ò', list(r.suggestedQuestions));
            }
          } catch (e) {
            console.warn('[BG] analyzeCompany failed, will fallback:', e?.message || e);
          }
        }

        // 2) ÂÖúÂ∫ïÔºöËá™Áî±ÂõûÁ≠îÔºàÊûÅÁÆÄ‰∏ä‰∏ãÊñá ‚Üí ‰∏ÄÂè•ËØù promptÔºâ
        if (!text) {
          console.log('[BG][PATH] company:fallback-prompt -> callChromeAIPrompt');
          const ctx = [
            d.companyName && `Company: ${d.companyName}`,
            d.companyUrl && `Website: ${d.companyUrl}`,
            d.targetPosition && `Target Position: ${d.targetPosition}`,
            d.additionalInfo && `Additional Info: ${(d.additionalInfo||'').slice(0,500)}`
          ].filter(Boolean).join('\n');

          const prompt =
            `Provide interview preparation in English, bullet-point format, based on the context:
            - Company positioning (one sentence)
            - Key timeline (3-5 points)
            - Competitive advantages (2-3 points)
            - Interview preparation tips (3-5 items)
            - Questions to ask the interviewer (3 questions)
            Provide general advice even if limited information is available.

      ${ctx || '(No context provided)'}`;

          text = await callChromeAIPrompt(prompt);
        }

        sendResponse({ status: 'SUCCESS', output: text || 'No analysis.' });
        break;
      }



      // Ëá™Ê£ÄÔºöÊää SMOKE ‰πü‰∫§Áªô offscreen
      case 'SMOKE_TEST': {
        const resp = await callOffscreen('OFFSCREEN_SMOKE');
        if (resp?.ok) sendResponse({ ok: true, out: resp.data });
        else sendResponse({ ok: false, err: resp?.error || 'OFFSCREEN_SMOKE failed' });
        break;
      }

      default:
        sendResponse({ status: 'ERROR', message: 'Unknown action: ' + request.action });
    }
  })().catch(e => sendResponse({ status: 'ERROR', message: String(e?.message || e) }));
  return true;
});

// Â§ÑÁêÜÊëòË¶ÅËØ∑Ê±ÇÔºàÊîπÔºö‰ªÖÊ£ÄÊü•Áä∂ÊÄÅ‚ÜíË∞ÉÁî®Êú¨Âú∞ LM via offscreenÔºâ
async function handleSummaryRequest(request, sendResponse) {
  if (modelStatus !== 'ready' && modelStatus !== 'partial') {
    sendResponse({
      status: 'ERROR',
      message: 'Chrome AI Êú™Â∞±Áª™„ÄÇËØ∑Ê£ÄÊü•ËÆæÁΩÆÂπ∂ÈáçËØï„ÄÇ',
      guidance: getSetupGuidance()
    });
    return;
  }
  try {
    console.log('üìÑ ‰ΩøÁî® Chrome AI Â§ÑÁêÜÊëòË¶ÅËØ∑Ê±Ç...');
    const summary = await chromeAIManager.summarizeContent(request.text);
    sendResponse({
      status: 'SUCCESS',
      output: summary,
      metadata: {
        ai_model: 'Gemini Nano (Chrome Built-in)',
        cost: 0,
        privacy: '100% Local processing'
      }
    });
  } catch (error) {
    console.error('Chrome AI ÊëòË¶ÅÂ§±Ë¥•:', error);
    sendResponse({
      status: 'ERROR',
      message: error.message || 'Chrome AI ÊëòË¶ÅÂ§±Ë¥•',
      suggestion: 'ËØ∑Ê£ÄÊü• Chrome AI ËÆæÁΩÆÊàñÂ∞ùËØïÂà∑Êñ∞È°µÈù¢'
    });
  }
}

// Â§ÑÁêÜProfileÂàÜÊûê
async function handleProfileAnalysis(request, sendResponse) {
  try {
    console.log('üë§ ‰ΩøÁî® Chrome AI Â§ÑÁêÜProfileÂàÜÊûê‚Ä¶');
    if (!chromeAIManager) throw new Error('Chrome AI Manager Êú™Initialization');

    const cached = await database?.getProfile(request.data.metadata?.profile_url);
    if (cached && !request.forceRefresh) {
      console.log('üìã ‰ΩøÁî®ÁºìÂ≠òÁöÑÂàÜÊûêÁªìÊûú');
      sendResponse({
        status: 'SUCCESS',
        data: cached.analyzed_data,
        fromCache: true,
        metadata: { source: 'Êú¨Âú∞ÁºìÂ≠ò', privacy: '100% Êú¨Âú∞Â≠òÂÇ®' }
      });
      return;
    }
    // ‰ΩøÁî® Chrome AI ÂàÜÊûê
    const result = await chromeAIManager.analyzeProfile(request.data);
    // ‰øùÂ≠òÁªìÊûúÂà∞Local database
    if (database && request.data.metadata?.profile_url) {
      await database.saveProfile({
        profile_url: request.data.metadata.profile_url,
        raw_data: request.data,
        analyzed_data: result,
        analyzed_at: Date.now()
      });
    }
    sendResponse({
      status: 'SUCCESS',
      data: result,
      metadata: { source: 'Chrome AI ÂÆûÊó∂ÂàÜÊûê', privacy: '100% Local processingÔºåÊï∞ÊçÆ‰∏çÁ¶ªÂºÄËÆæÂ§á' }
    });
  } catch (error) {
    console.error('Chrome AI ProfileAnalysis failed:', error);
    sendResponse({ status: 'ERROR', message: error.message, suggestion: 'ËØ∑Ê£ÄÊü• Chrome AI ËÆæÁΩÆÊàñÂà∑Êñ∞È°µÈù¢' });
  }
}

// Â§ÑÁêÜÂÖ¨Âè∏ÂàÜÊûê
async function handleCompanyAnalysis(request, sendResponse) {
  try {
    console.log('üè¢ ‰ΩøÁî® Chrome AI Â§ÑÁêÜÂÖ¨Âè∏ÂàÜÊûê‚Ä¶');
    if (!chromeAIManager) throw new Error('Chrome AI Manager Êú™Initialization');

    const cacheKey = request.data.companyUrl || request.data.companyName;
    const cached = await database?.getCompany(cacheKey);
    if (cached && !request.forceRefresh) {
      console.log('üìã ‰ΩøÁî®ÁºìÂ≠òÁöÑÂÖ¨Âè∏ÂàÜÊûêÁªìÊûú');
      sendResponse({
        status: 'SUCCESS', data: cached.analyzed_data, fromCache: true,
        metadata: { source: 'Êú¨Âú∞ÁºìÂ≠ò', privacy: '100% Êú¨Âú∞Â≠òÂÇ®' }
      });
      return;
    }

    const result = await chromeAIManager.analyzeCompany(request.data);
    if (database) {
      await database.saveCompany({
        company_name: request.data.companyName,
        website_url: request.data.companyUrl,
        raw_data: request.data,
        analyzed_data: result,
        analyzed_at: Date.now()
      });
    }
    sendResponse({
      status: 'SUCCESS', data: result,
      metadata: { source: 'Chrome AI ÂÆûÊó∂ÂàÜÊûê', privacy: '100% Local processing' }
    });
  } catch (error) {
    console.error('Chrome AI ÂÖ¨Âè∏Analysis failed:', error);
    sendResponse({ status: 'ERROR', message: error.message, suggestion: 'ËØ∑Ê£ÄÊü• Chrome AI ËÆæÁΩÆÊàñÂà∑Êñ∞È°µÈù¢' });
  }
}

// Â§ÑÁêÜÁΩëÁ´ôÂàÜÊûê
async function handleWebsiteAnalysis(request, sendResponse) {
  try {
    const companyData = {
      companyName: extractCompanyNameFromUrl(request.data.url),
      companyUrl: request.data.url,
      additionalInfo: request.data.content?.substring(0, 1000)
    };
    await handleCompanyAnalysis({ data: companyData, context: request.context }, sendResponse);
  } catch (error) {
    console.error('Website analysis failed:', error);
    sendResponse({ status: 'ERROR', message: error.message });
  }
}

// Ëé∑ÂèñÁªüËÆ°Êï∞ÊçÆ
async function handleGetStats(_request, sendResponse) {
  try {
    const stats = {
      aiManager: chromeAIManager ? await chromeAIManager.getStats() : {
        modelStatus, capabilities: aiCapabilities, cost: 0, privacy: '100% Local processing'
      },
      database: database ? await database.getCostSummary() : null
    };
    sendResponse({ status: 'SUCCESS', data: stats });
  } catch (error) {
    console.error('Failed to get stats:', error);
    sendResponse({ status: 'ERROR', message: error.message });
  }
}

// Â§ÑÁêÜLinkedInProfileÊï∞ÊçÆËé∑Âèñ
async function handleGetLinkedInProfileData(_request, sendResponse) {
  try {
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
    if (!tab || !tab.url.includes('linkedin.com/in/')) {
      throw new Error('ËØ∑Âú®LinkedInProfileÈ°µÈù¢‰ΩøÁî®Ê≠§ÂäüËÉΩ');
    }
    await ensureContentScriptLoaded(tab.id);

    const response = await sendMessageWithRetry(tab.id, { action: 'SCRAPE_LINKEDIN_PROFILE' }, 3);
    if (response && response.status === 'SUCCESS') {
      sendResponse({ status: 'SUCCESS', data: response.data });
    } else {
      throw new Error(response?.message || 'LinkedInÊï∞ÊçÆËé∑ÂèñÂ§±Ë¥•');
    }
  } catch (error) {
    console.error('LinkedIn profile data fetch failed:', error);
    sendResponse({ status: 'ERROR', message: error.message });
  }
}

// Á°Æ‰øùcontent scriptÂ∑≤Âä†ËΩΩ
async function ensureContentScriptLoaded(tabId) {
  try {
    try {
      const ping = await chrome.tabs.sendMessage(tabId, { action: 'PING' });
      if (ping && ping.status === 'PONG') return;
    } catch (_) {}
    await new Promise(r => setTimeout(r, 2000));
    try {
      const test = await chrome.tabs.sendMessage(tabId, { action: 'PING' });
      if (test && test.status === 'PONG') return;
    } catch (_) {}
    await chrome.scripting.executeScript({ target: { tabId }, files: ['content-script.js'] });
    await new Promise(r => setTimeout(r, 1000));
  } catch (error) {
    console.error('Failed to ensure content script loaded:', error);
    throw new Error('ËØ∑Âà∑Êñ∞LinkedInÈ°µÈù¢ÂêéÈáçËØï');
  }
}

// Â∏¶ÈáçËØïÁöÑMessage Sending
async function sendMessageWithRetry(tabId, message, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await chrome.tabs.sendMessage(tabId, message);
    } catch (error) {
      if (i === maxRetries - 1) throw new Error('Êó†Ê≥ï‰∏éÈ°µÈù¢Âª∫Á´ãËøûÊé•ÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÂêéÈáçËØï');
      await new Promise(r => setTimeout(r, 500 * (i + 1)));
    }
  }
}

// ËæÖÂä©ÂáΩÊï∞Ôºö‰ªéURLÊèêÂèñÂÖ¨Âè∏ÂêçÁß∞
function extractCompanyNameFromUrl(url) {
  try {
    const hostname = new URL(url).hostname;
    const parts = hostname.split('.');
    const mainPart = parts.length > 2 ? parts[parts.length - 2] : parts[0];
    return mainPart.charAt(0).toUpperCase() + mainPart.slice(1);
  } catch (_) {
    return 'Unknown Company';
  }
}

// 3. ÂêØÂä®ÊâÄÊúâÊúçÂä°Initialization
initializeServices();

// 4. ÁõëÂê¨Êâ©Â±ïÂÆâË£ÖÂíåÊõ¥Êñ∞‰∫ã‰ª∂
chrome.runtime.onInstalled.addListener((details) => {
  console.log('SmartInsight Chrome AI installed/updated:', details.reason);
  if (details.reason === 'install') {		
    // È¶ñÊ¨°ÂÆâË£ÖÊó∂ÈÖçÁΩÆ Chrome AI ÁéØÂ¢É
    autoSetupTestEnvironment();
  }
  // Êîπ: ÂÆâË£Ö/Êõ¥Êñ∞Âêé‰∏ªÂä®È¢ÑÁÉ≠‰∏ÄÊ¨°
  prewarmLM();
});

// ÊµèËßàÂô®ÈáçÂêØÂêé‰πüÈ¢ÑÁÉ≠
chrome.runtime.onStartup?.addListener(() => {
  prewarmLM();
});


// Chrome AI ËÆæÁΩÆÊåáÂØº
function getSetupGuidance() {
  return {
    title: 'ÂêØÁî® Chrome AI ÂäüËÉΩ',
    steps: [
      '1. Á°Æ‰øù‰ΩøÁî® Chrome 127+ (Dev/Canary ÁâàÊú¨)',
      '2. ËÆøÈóÆ chrome://flags/#optimization-guide-on-device-model',
      '3. ËÆæÁΩÆ‰∏∫ "Enabled BypassPrefRequirement"',
      '4. ËÆøÈóÆ chrome://flags/#prompt-api-for-gemini-nano',
      '5. ËÆæÁΩÆ‰∏∫ "Enabled"',
      '6. ÈáçÂêØÊµèËßàÂô®',
      '7. Á≠âÂæÖ Gemini Nano Model download complete'
    ],
    benefits: [
      'üîí ÂÆåÂÖ®ÈöêÁßÅ‰øùÊä§ - Êï∞ÊçÆ‰∏çÁ¶ªÂºÄËÆæÂ§á',
      '‚ö° ÊûÅÈÄüÂìçÂ∫î - Local processingÊó†Âª∂Ëøü',
      'üí∞ Completely Free - Êó†ÈúÄ‰ªª‰Ωï API ÂØÜÈí•',
      'üì¥ Á¶ªÁ∫øÂèØÁî® - Êó†ÈúÄÁΩëÁªúËøûÊé•'
    ]
  };
}

// Ëá™Âä®ÈÖçÁΩÆ Chrome AI ÁéØÂ¢ÉÔºàÊîπÔºö‰∏çÂÜçËß¶Á¢∞ self.aiÔºåÁªü‰∏ÄÁî® offscreen smokeÔºâ
async function autoSetupTestEnvironment() {
  console.log('üöÄ ÈÖçÁΩÆ Chrome AI ÁéØÂ¢É...');
  const chromeAIConfig = {
    chrome_ai_enabled: true,
    privacy_mode: true,
    offline_capable: true,
    cost_tracking: false,
    setup_completed: Date.now()
  };
  try {
    await chrome.storage.local.set(chromeAIConfig);
    console.log('‚úÖ Chrome AI ÈÖçÁΩÆÂ∑≤‰øùÂ≠ò');

    setTimeout(async () => {
      try {
        const smoke = await callOffscreen('OFFSCREEN_SMOKE'); // Êîπ
        if (smoke?.ok) {
          console.log('‚úÖ Chrome AI Â∑≤Â∞±Áª™!');
          try {
            chrome.notifications.create({
              type: 'basic',
              iconUrl: ICON,
              title: 'SmartInsight Chrome AI Â∞±Áª™',
              message: 'üîí Privacy First | ‚ö° Local AI | üí∞ Completely Free'
            });
          } catch (_) {}
        } else {
          console.log('üì• Ê®°ÂûãÂ∞öÊú™ÂèØÁî®ÊàñÊ≠£Âú®‰∏ãËΩΩ‚Ä¶');
          try {
            chrome.notifications.create({
              type: 'basic',
              iconUrl: ICON,
              title: 'Chrome AI Ê®°ÂûãÂáÜÂ§á‰∏≠',
              message: 'Â¶ÇÈ¶ñÊ¨°‰ΩøÁî®ÔºåËØ∑Á≠âÂæÖÊú¨Âú∞Ê®°ÂûãÂáÜÂ§áÂ∞±Áª™'
            });
          } catch (_) {}
        }
      } catch (error) {
        console.error('‚ùå Chrome AI Ëá™Ê£ÄÂ§±Ë¥•:', error);
      }
    }, 1000);
  } catch (error) {
    console.error('‚ùå Chrome AI ÈÖçÁΩÆÂ§±Ë¥•:', error);
  }
}


// 5) ÁõëÂê¨Ê†áÁ≠æÈ°µÊõ¥Êñ∞

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  if (changeInfo.status === 'complete' && tab.url) {
    const url = new URL(tab.url);
    if (url.hostname === 'www.linkedin.com' && (url.pathname.includes('/in/') || url.pathname.includes('/company/'))) {
      console.log('LinkedIn page detected:', url.pathname);
    }
  }
});

// ========================================
// Êñ∞Â¢ûÔºöscenariosÂª∫ËÆÆÂíåËÅäÂ§©Â§ÑÁêÜÂáΩÊï∞
// ========================================

// Â§ÑÁêÜscenariosÂª∫ËÆÆÁîüÊàê
async function handleScenarioAdvice(request, sendResponse) {
  try {
    console.log(`üéØ ÁîüÊàê ${request.scenario} scenariosÂª∫ËÆÆ...`);
    console.log('üìä Target Data:', request.targetData);
    
    const prompt = request.prompt || buildScenarioPrompt(request.scenario, request.targetData);
    console.log('üìù Generated Prompt:', prompt.substring(0, 200) + '...');
    
    const result = await callChromeAIPrompt(prompt);
    
    sendResponse({
      status: 'SUCCESS',
      output: result,
      metadata: {
        scenario: request.scenario,
        ai_model: 'Gemini Nano (Chrome Built-in)',
        cost: 0,
        privacy: '100% Local processing'
      }
    });
  } catch (error) {
    console.error('scenariosÂª∫ËÆÆGeneration failed:', error);
    sendResponse({
      status: 'ERROR',
      message: error.message || 'scenariosÂª∫ËÆÆGeneration failed'
    });
  }
}

// Â§ÑÁêÜËÅäÂ§©Ê∂àÊÅØ
async function handleChatMessage(request, sendResponse) {
  try {
    console.log('üí¨ Â§ÑÁêÜËÅäÂ§©Ê∂àÊÅØ...');
    
    // BuildingÂåÖÂê´‰∏ä‰∏ãÊñáÁöÑ prompt
    const prompt = buildChatPrompt(request.message, request.context, request.scenario, request.targetData);
    const result = await callChromeAIPrompt(prompt);
    
    sendResponse({
      status: 'SUCCESS',
      output: result,
      metadata: {
        ai_model: 'Gemini Nano (Chrome Built-in)',
        cost: 0,
        privacy: '100% Local processing'
      }
    });
  } catch (error) {
    console.error('ËÅäÂ§©Ê∂àÊÅØÂ§ÑÁêÜÂ§±Ë¥•:', error);
    sendResponse({
      status: 'ERROR',
      message: error.message || 'Ê∂àÊÅØÂ§ÑÁêÜÂ§±Ë¥•'
    });
  }
}

// Â§ÑÁêÜOpen Side Panel
async function handleOpenSidePanel(request, sender, sendResponse) {
  try {
    console.log('üìÇ Open Side Panel...');
    
    // Ëé∑ÂèñÂèëÈÄÅËÄÖÁöÑÁ™óÂè£ ID
    const windowId = sender.tab?.windowId;
    
    if (!windowId) {
      throw new Error('Êó†Ê≥ïËé∑ÂèñÁ™óÂè£ID');
    }
    
    // Open Side Panel
    await chrome.sidePanel.open({ windowId });
    
    sendResponse({
      status: 'SUCCESS',
      message: 'Side Panel opened'
    });
  } catch (error) {
    console.error('Open Side Panel Â§±Ë¥•:', error);
    sendResponse({
      status: 'ERROR',
      message: error.message || 'ÊâìÂºÄÂ§±Ë¥•'
    });
  }
}

// Â§ÑÁêÜËá™Âä®Import LinkedIn
async function handleAutoImportLinkedIn(request, sender, sendResponse) {
  try {
    console.log('üì• Ëá™Âä®Import LinkedIn Êï∞ÊçÆ...');
    
    // Âêë Side Panel ÂèëÈÄÅImportÊåá‰ª§
    // Ê≥®ÊÑèÔºöËøôÈáåÈúÄË¶ÅÊâæÂà∞ Side Panel ÁöÑ tab Âπ∂Send message
    const tabs = await chrome.tabs.query({});
    const sidePanelTab = tabs.find(tab => tab.url?.includes('sidepanel.html'));
    
    if (sidePanelTab) {
      await chrome.tabs.sendMessage(sidePanelTab.id, {
        action: 'TRIGGER_IMPORT',
        type: request.type,
        url: request.url
      });
      
      sendResponse({
        status: 'SUCCESS',
        message: 'Â∑≤Trigger import'
      });
    } else {
      // Side Panel ÂèØËÉΩËøòÊ≤°ÂÆåÂÖ®Âä†ËΩΩÔºå‰ΩøÁî® storage ‰º†ÈÄíÊåá‰ª§
      await chrome.storage.local.set({
        pendingImport: {
          type: request.type,
          url: request.url,
          timestamp: Date.now()
        }
      });
      
      sendResponse({
        status: 'SUCCESS',
        message: 'ImportÊåá‰ª§Â∑≤‰øùÂ≠ò'
      });
    }
  } catch (error) {
    console.error('Auto import failed:', error);
    sendResponse({
      status: 'ERROR',
      message: error.message || 'ImportÂ§±Ë¥•'
    });
  }
}

// Buildingscenarios Prompt
function buildScenarioPrompt(scenario, targetData) {
  if (scenario === 'coffee-chat') {
    return buildCoffeeChatPrompt(targetData);
  } else if (scenario === 'networking') {
    return buildNetworkingPrompt(targetData);
  }
  return 'Please provide scenario advice in English.';
}

// Coffee Chat Prompt
function buildCoffeeChatPrompt(targetData) {
  const name = targetData?.basic_info?.name || targetData?.name || 'the person';
  const headline = targetData?.basic_info?.headline || targetData?.headline || '';
  const currentCompany = targetData?.current_position?.company || targetData?.company || '';
  
  const experiences = targetData?.experiences?.slice(0, 3).map(exp => 
    `- ${exp.title} @ ${exp.company} (${exp.duration || ''})`
  ).join('\n') || '';
  
  const education = targetData?.education?.slice(0, 2).map(edu => 
    `- ${edu.school} - ${edu.degree || ''} ${edu.field || ''}`
  ).join('\n') || '';

  // ÊèêÂèñÂÖ≥ÈîÆ‰ø°ÊÅØÁî®‰∫éÁîüÊàêÂÖ∑‰ΩìÈóÆÈ¢ò
  const latestCompany = targetData?.experiences?.[0]?.company || currentCompany;
  const latestTitle = targetData?.experiences?.[0]?.title || headline;
  const previousCompany = targetData?.experiences?.[1]?.company || '';
  const school = targetData?.education?.[0]?.school || '';

  return `IMPORTANT: RESPOND WITH PLAIN TEXT ONLY. DO NOT GENERATE HTML CODE OR MARKUP.

You are a career networking expert. Generate personalized Coffee Chat questions.

TARGET INFORMATION:
Name: ${name}
Current Role: ${headline} at ${currentCompany}
${latestCompany && latestCompany !== currentCompany ? `Previous Role: ${latestTitle} at ${latestCompany}` : ''}
${previousCompany ? `Earlier Experience: ${previousCompany}` : ''}
${school ? `Education: ${school}` : ''}

Generate 3 specific, personalized questions for each section. Use EXACTLY this format:

‚îÅ‚îÅ‚îÅ Icebreaker (0-15 min) ‚îÅ‚îÅ‚îÅ

‚Ä¢ Question 1 based on their career path
‚Ä¢ Question 2 about their current role
‚Ä¢ Question 3 about their transition or company

‚îÅ‚îÅ‚îÅ Industry Insights (15-35 min) ‚îÅ‚îÅ‚îÅ

‚Ä¢ Question 1 about industry challenges
‚Ä¢ Question 2 about company positioning
‚Ä¢ Question 3 about future trends

‚îÅ‚îÅ‚îÅ Career Advice (35-45 min) ‚îÅ‚îÅ‚îÅ

‚Ä¢ Question 1 about joining their company
‚Ä¢ Question 2 about skill development
‚Ä¢ Question 3 about career advice

‚ö†Ô∏è Avoid:
‚Ä¢ Salary questions
‚Ä¢ Referral requests (first meeting)
‚Ä¢ Personal questions

üìù Follow-up Email:

Subject: Thank you for the Coffee Chat

Dear ${name},

Thank you for taking the time to meet with me today. Your insights about ${currentCompany} were invaluable.

Add 1-2 sentences referencing specific topics discussed.

Looking forward to staying in touch!

Best,
[Your Name]

CRITICAL FORMATTING RULES:
- Output PLAIN TEXT ONLY - NO HTML, NO CODE, NO MARKUP
- DO NOT use asterisks, brackets, or any markdown formatting
- DO NOT generate HTML tags like <div>, <style>, or any code
- Each question MUST start with ‚Ä¢ on a new line
- Write questions as complete sentences in quotes
- Questions should reference REAL data from the target information above
- Be specific and natural, not generic
- Output in English only
- DO NOT include phrases like "Question 1:" or "based on" - write the actual questions directly
- This is a TEXT-ONLY response, not HTML or code`;
}

// Networking Prompt
function buildNetworkingPrompt(targetData) {
  const name = targetData?.basic_info?.name || targetData?.name || 'the person';
  const headline = targetData?.basic_info?.headline || targetData?.headline || '';
  const currentCompany = targetData?.current_position?.company || targetData?.company || '';
  const latestCompany = targetData?.experiences?.[0]?.company || currentCompany;
  const latestTitle = targetData?.experiences?.[0]?.title || headline;
  
  return `IMPORTANT: RESPOND WITH PLAIN TEXT ONLY. DO NOT GENERATE HTML CODE OR MARKUP.

You are a career fair networking expert. Generate quick networking strategy.

TARGET INFORMATION:
Name: ${name}
Current Role: ${headline} at ${currentCompany}
${latestCompany && latestCompany !== currentCompany ? `Previous Role: ${latestTitle} at ${latestCompany}` : ''}

Generate content for a 2-10 minute Career Fair interaction. Use EXACTLY this format:

‚îÅ‚îÅ‚îÅ Elevator Pitch (2 min) ‚îÅ‚îÅ‚îÅ

‚Ä¢ Write a concise 150-word elevator pitch mentioning your background, why interested in ${currentCompany}, and what role you're targeting

‚îÅ‚îÅ‚îÅ Smart Questions ‚îÅ‚îÅ‚îÅ

‚Ä¢ Question showing you follow ${currentCompany} - mention recent news or initiatives
‚Ä¢ Question showing you understand the industry
‚Ä¢ Question showing genuine interest in working there

‚îÅ‚îÅ‚îÅ Get Contact ‚îÅ‚îÅ‚îÅ

‚Ä¢ After intro: Natural way to ask for contact after they introduce ${currentCompany}
‚Ä¢ When matched: How to exchange contact when your experience aligns
‚Ä¢ Time limited: Quick way to get contact when others are waiting

‚îÅ‚îÅ‚îÅ Follow-up Email ‚îÅ‚îÅ‚îÅ

Subject: Great meeting you at the Career Fair

Dear ${name},

Thank you for taking the time to speak with me about ${currentCompany}. Your insights about ${latestTitle ? `the ${latestTitle} role` : 'the company'} were very valuable.

Add 1-2 sentences about specific topics discussed.

Looking forward to staying in touch!

Best,
[Your Name]

CRITICAL FORMATTING RULES:
- Output PLAIN TEXT ONLY - NO HTML, NO CODE, NO MARKUP
- DO NOT use asterisks, brackets, or any markdown formatting
- DO NOT generate HTML tags like <div>, <style>, or any code
- Each item MUST start with ‚Ä¢ on a new line
- Write complete sentences, not instructions
- Be specific to ${currentCompany} and ${name}'s role
- Keep it concise and actionable
- Output in English only
- DO NOT include labels like "Question 1:" - write the actual content directly
- This is a TEXT-ONLY response, not HTML or code`;
}

// Building Chat Prompt
function buildChatPrompt(message, context, scenario, targetData) {
  let systemPrompt = 'You are a professional career networking assistant. Always respond in English.';
  
  if (scenario === 'coffee-chat') {
    systemPrompt += ' Current scenario: Coffee Chat (30-60 minute deep conversation). Provide in-depth, layered advice.';
  } else if (scenario === 'networking') {
    systemPrompt += ' Current scenario: Networking (2-10 minute quick interaction). Provide concise, practical advice.';
  }
  
  // Add Target Person Information
  let contextInfo = '';
  if (targetData) {
    contextInfo = `\n\n[Target Person Information]\n`;
    contextInfo += `Name: ${targetData.name || 'Unknown'}\n`;
    contextInfo += `Position: ${targetData.headline || 'Unknown'}\n`;
    contextInfo += `Company: ${targetData.company || 'Unknown'}\n`;
  }
  
  // Add conversation history
  let conversationHistory = '';
  if (context?.recentMessages && context.recentMessages.length > 0) {
    conversationHistory = '\n\n[Recent Conversation]\n';
    context.recentMessages.forEach(msg => {
      conversationHistory += `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}\n`;
    });
  }
  
  return `${systemPrompt}${contextInfo}${conversationHistory}\n\n[Current Question]\n${message}\n\nProvide a professional, practical response in English. Be direct and address the user's specific request.\n\nIMPORTANT: Output PLAIN TEXT ONLY - NO HTML, NO CODE, NO MARKUP. Do not generate HTML tags or any code.`;
}
